/*
 * Typesense API
 *
 * An open source search engine for building delightful search experiences.
 *
 * The version of the OpenAPI document: 27.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::{apis::ResponseContent, models};
use async_trait::async_trait;
use reqwest;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;

#[async_trait]
pub trait DocumentsApi: Send + Sync {
    async fn delete_document(&self, params: DeleteDocumentParams) -> Result<serde_json::Value, Error<DeleteDocumentError>>;
    async fn delete_documents(&self, params: DeleteDocumentsParams) -> Result<models::DeleteDocuments200Response, Error<DeleteDocumentsError>>;
    async fn delete_search_override(&self, params: DeleteSearchOverrideParams) -> Result<models::SearchOverrideDeleteResponse, Error<DeleteSearchOverrideError>>;
    async fn export_documents(&self, params: ExportDocumentsParams) -> Result<String, Error<ExportDocumentsError>>;
    async fn get_document(&self, params: GetDocumentParams) -> Result<serde_json::Value, Error<GetDocumentError>>;
    async fn get_search_override(&self, params: GetSearchOverrideParams) -> Result<models::SearchOverride, Error<GetSearchOverrideError>>;
    async fn get_search_overrides(&self, params: GetSearchOverridesParams) -> Result<models::SearchOverridesResponse, Error<GetSearchOverridesError>>;
    async fn import_documents(&self, params: ImportDocumentsParams) -> Result<String, Error<ImportDocumentsError>>;
    async fn index_document(&self, params: IndexDocumentParams) -> Result<serde_json::Value, Error<IndexDocumentError>>;
    async fn multi_search(&self, params: MultiSearchParams) -> Result<models::MultiSearchResult, Error<MultiSearchError>>;
    async fn search_collection(&self, params: SearchCollectionParams) -> Result<models::SearchResult, Error<SearchCollectionError>>;
    async fn update_document(&self, params: UpdateDocumentParams) -> Result<serde_json::Value, Error<UpdateDocumentError>>;
    async fn update_documents(&self, params: UpdateDocumentsParams) -> Result<models::UpdateDocuments200Response, Error<UpdateDocumentsError>>;
    async fn upsert_search_override(&self, params: UpsertSearchOverrideParams) -> Result<models::SearchOverride, Error<UpsertSearchOverrideError>>;
}

pub struct DocumentsApiClient {
    configuration: Arc<Mutex<configuration::Configuration>>,
}

impl DocumentsApiClient {
    pub fn new(configuration: Arc<Mutex<configuration::Configuration>>) -> Self {
        Self { configuration }
    }
}

/// struct for passing parameters to the method [`delete_document`]
#[derive(Clone, Debug)]
pub struct DeleteDocumentParams {
    /// The name of the collection to search for the document under
    pub collection_name: String,
    /// The Document ID
    pub document_id: String,
}

/// struct for passing parameters to the method [`delete_documents`]
#[derive(Clone, Debug)]
pub struct DeleteDocumentsParams {
    /// The name of the collection to delete documents from
    pub collection_name: String,
    pub batch_size: Option<i32>,
    pub filter_by: Option<String>,
    pub ignore_not_found: Option<bool>,
}

/// struct for passing parameters to the method [`delete_search_override`]
#[derive(Clone, Debug)]
pub struct DeleteSearchOverrideParams {
    /// The name of the collection
    pub collection_name: String,
    /// The ID of the search override to delete
    pub override_id: String,
}

/// struct for passing parameters to the method [`export_documents`]
#[derive(Clone, Debug)]
pub struct ExportDocumentsParams {
    /// The name of the collection
    pub collection_name: String,
    pub exclude_fields: Option<String>,
    pub filter_by: Option<String>,
    pub include_fields: Option<String>,
}

/// struct for passing parameters to the method [`get_document`]
#[derive(Clone, Debug)]
pub struct GetDocumentParams {
    /// The name of the collection to search for the document under
    pub collection_name: String,
    /// The Document ID
    pub document_id: String,
}

/// struct for passing parameters to the method [`get_search_override`]
#[derive(Clone, Debug)]
pub struct GetSearchOverrideParams {
    /// The name of the collection
    pub collection_name: String,
    /// The id of the search override
    pub override_id: String,
}

/// struct for passing parameters to the method [`get_search_overrides`]
#[derive(Clone, Debug)]
pub struct GetSearchOverridesParams {
    /// The name of the collection
    pub collection_name: String,
}

/// struct for passing parameters to the method [`import_documents`]
#[derive(Clone, Debug)]
pub struct ImportDocumentsParams {
    /// The name of the collection
    pub collection_name: String,
    /// The json array of documents or the JSONL file to import
    pub body: String,
    pub action: Option<models::IndexAction>,
    pub batch_size: Option<i32>,
    pub dirty_values: Option<models::DirtyValues>,
    pub remote_embedding_batch_size: Option<i32>,
    pub return_doc: Option<bool>,
    pub return_id: Option<bool>,
}

/// struct for passing parameters to the method [`index_document`]
#[derive(Clone, Debug)]
pub struct IndexDocumentParams {
    /// The name of the collection to add the document to
    pub collection_name: String,
    /// The document object to be indexed
    pub body: serde_json::Value,
    /// Additional action to perform
    pub action: Option<String>,
    /// Dealing with Dirty Data
    pub dirty_values: Option<models::DirtyValues>,
}

/// struct for passing parameters to the method [`multi_search`]
#[derive(Clone, Debug)]
pub struct MultiSearchParams {
    pub cache_ttl: Option<i32>,
    pub conversation: Option<bool>,
    pub conversation_id: Option<String>,
    pub conversation_model_id: Option<String>,
    pub drop_tokens_mode: Option<models::DropTokensMode>,
    pub drop_tokens_threshold: Option<i32>,
    pub enable_highlight_v1: Option<bool>,
    pub enable_overrides: Option<bool>,
    pub enable_synonyms: Option<bool>,
    pub enable_typos_for_alpha_numerical_tokens: Option<bool>,
    pub enable_typos_for_numerical_tokens: Option<bool>,
    pub exclude_fields: Option<String>,
    pub exhaustive_search: Option<bool>,
    pub facet_by: Option<String>,
    pub facet_query: Option<String>,
    pub facet_return_parent: Option<String>,
    pub facet_strategy: Option<String>,
    pub filter_by: Option<String>,
    pub filter_curated_hits: Option<bool>,
    pub group_by: Option<String>,
    pub group_limit: Option<i32>,
    pub group_missing_values: Option<bool>,
    pub hidden_hits: Option<String>,
    pub highlight_affix_num_tokens: Option<i32>,
    pub highlight_end_tag: Option<String>,
    pub highlight_fields: Option<String>,
    pub highlight_full_fields: Option<String>,
    pub highlight_start_tag: Option<String>,
    pub include_fields: Option<String>,
    pub infix: Option<String>,
    pub limit: Option<i32>,
    pub max_candidates: Option<i32>,
    pub max_extra_prefix: Option<i32>,
    pub max_extra_suffix: Option<i32>,
    pub max_facet_values: Option<i32>,
    pub min_len_1typo: Option<i32>,
    pub min_len_2typo: Option<i32>,
    pub num_typos: Option<String>,
    pub offset: Option<i32>,
    pub override_tags: Option<String>,
    pub page: Option<i32>,
    pub per_page: Option<i32>,
    pub pinned_hits: Option<String>,
    pub pre_segmented_query: Option<bool>,
    pub prefix: Option<String>,
    pub preset: Option<String>,
    pub prioritize_exact_match: Option<bool>,
    pub prioritize_num_matching_fields: Option<bool>,
    pub prioritize_token_position: Option<bool>,
    pub q: Option<String>,
    pub query_by: Option<String>,
    pub query_by_weights: Option<String>,
    pub remote_embedding_num_tries: Option<i32>,
    pub remote_embedding_timeout_ms: Option<i32>,
    pub search_cutoff_ms: Option<i32>,
    pub snippet_threshold: Option<i32>,
    pub sort_by: Option<String>,
    pub split_join_tokens: Option<String>,
    pub stopwords: Option<String>,
    pub synonym_num_typos: Option<i32>,
    pub synonym_prefix: Option<bool>,
    pub text_match_type: Option<String>,
    pub typo_tokens_threshold: Option<i32>,
    pub use_cache: Option<bool>,
    pub vector_query: Option<String>,
    pub voice_query: Option<String>,
    pub multi_search_searches_parameter: Option<models::MultiSearchSearchesParameter>,
}

/// struct for passing parameters to the method [`search_collection`]
#[derive(Clone, Debug)]
pub struct SearchCollectionParams {
    /// The name of the collection to search for the document under
    pub collection_name: String,
    pub cache_ttl: Option<i32>,
    pub conversation: Option<bool>,
    pub conversation_id: Option<String>,
    pub conversation_model_id: Option<String>,
    pub drop_tokens_mode: Option<models::DropTokensMode>,
    pub drop_tokens_threshold: Option<i32>,
    pub enable_highlight_v1: Option<bool>,
    pub enable_overrides: Option<bool>,
    pub enable_synonyms: Option<bool>,
    pub enable_typos_for_alpha_numerical_tokens: Option<bool>,
    pub enable_typos_for_numerical_tokens: Option<bool>,
    pub exclude_fields: Option<String>,
    pub exhaustive_search: Option<bool>,
    pub facet_by: Option<String>,
    pub facet_query: Option<String>,
    pub facet_return_parent: Option<String>,
    pub facet_strategy: Option<String>,
    pub filter_by: Option<String>,
    pub filter_curated_hits: Option<bool>,
    pub group_by: Option<String>,
    pub group_limit: Option<i32>,
    pub group_missing_values: Option<bool>,
    pub hidden_hits: Option<String>,
    pub highlight_affix_num_tokens: Option<i32>,
    pub highlight_end_tag: Option<String>,
    pub highlight_fields: Option<String>,
    pub highlight_full_fields: Option<String>,
    pub highlight_start_tag: Option<String>,
    pub include_fields: Option<String>,
    pub infix: Option<String>,
    pub limit: Option<i32>,
    pub max_candidates: Option<i32>,
    pub max_extra_prefix: Option<i32>,
    pub max_extra_suffix: Option<i32>,
    pub max_facet_values: Option<i32>,
    pub min_len_1typo: Option<i32>,
    pub min_len_2typo: Option<i32>,
    pub num_typos: Option<String>,
    pub offset: Option<i32>,
    pub override_tags: Option<String>,
    pub page: Option<i32>,
    pub per_page: Option<i32>,
    pub pinned_hits: Option<String>,
    pub pre_segmented_query: Option<bool>,
    pub prefix: Option<String>,
    pub preset: Option<String>,
    pub prioritize_exact_match: Option<bool>,
    pub prioritize_num_matching_fields: Option<bool>,
    pub prioritize_token_position: Option<bool>,
    pub q: Option<String>,
    pub query_by: Option<String>,
    pub query_by_weights: Option<String>,
    pub remote_embedding_num_tries: Option<i32>,
    pub remote_embedding_timeout_ms: Option<i32>,
    pub search_cutoff_ms: Option<i32>,
    pub snippet_threshold: Option<i32>,
    pub sort_by: Option<String>,
    pub split_join_tokens: Option<String>,
    pub stopwords: Option<String>,
    pub synonym_num_typos: Option<i32>,
    pub synonym_prefix: Option<bool>,
    pub text_match_type: Option<String>,
    pub typo_tokens_threshold: Option<i32>,
    pub use_cache: Option<bool>,
    pub vector_query: Option<String>,
    pub voice_query: Option<String>,
}

/// struct for passing parameters to the method [`update_document`]
#[derive(Clone, Debug)]
pub struct UpdateDocumentParams {
    /// The name of the collection to search for the document under
    pub collection_name: String,
    /// The Document ID
    pub document_id: String,
    /// The document object with fields to be updated
    pub body: serde_json::Value,
    /// Dealing with Dirty Data
    pub dirty_values: Option<models::DirtyValues>,
}

/// struct for passing parameters to the method [`update_documents`]
#[derive(Clone, Debug)]
pub struct UpdateDocumentsParams {
    /// The name of the collection to update documents in
    pub collection_name: String,
    /// The document fields to be updated
    pub body: serde_json::Value,
    pub filter_by: Option<String>,
}

/// struct for passing parameters to the method [`upsert_search_override`]
#[derive(Clone, Debug)]
pub struct UpsertSearchOverrideParams {
    /// The name of the collection
    pub collection_name: String,
    /// The ID of the search override to create/update
    pub override_id: String,
    /// The search override object to be created/updated
    pub search_override_schema: models::SearchOverrideSchema,
}

#[async_trait]
impl DocumentsApi for DocumentsApiClient {
    /// Delete an individual document from a collection by using its ID.
    async fn delete_document(&self, params: DeleteDocumentParams) -> Result<serde_json::Value, Error<DeleteDocumentError>> {
        let DeleteDocumentParams { collection_name, document_id } = params;

        let local_var_configuration = self.configuration.lock().await;
        let mut cloned = local_var_configuration.clone();
        let local_var_client = &mut cloned.client;

        let local_var_uri_str = format!(
            "{}/collections/{collectionName}/documents/{documentId}",
            local_var_configuration.base_path,
            collectionName = crate::apis::urlencode(collection_name),
            documentId = crate::apis::urlencode(document_id)
        );
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_apikey) = local_var_configuration.api_key {
            let local_var_key = local_var_apikey.key.clone();
            let local_var_value = match local_var_apikey.prefix {
                Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
                None => local_var_key,
            };
            local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<DeleteDocumentError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Delete a bunch of documents that match a specific filter condition. Use the `batch_size` parameter to control the number of documents that should deleted at a time. A larger value will speed up deletions, but will impact performance of other operations running on the server.
    async fn delete_documents(&self, params: DeleteDocumentsParams) -> Result<models::DeleteDocuments200Response, Error<DeleteDocumentsError>> {
        let DeleteDocumentsParams {
            collection_name,
            batch_size,
            filter_by,
            ignore_not_found,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/collections/{collectionName}/documents",
            local_var_configuration.base_path,
            collectionName = crate::apis::urlencode(collection_name)
        );
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = batch_size {
            local_var_req_builder = local_var_req_builder.query(&[("batch_size", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_by {
            local_var_req_builder = local_var_req_builder.query(&[("filter_by", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ignore_not_found {
            local_var_req_builder = local_var_req_builder.query(&[("ignore_not_found", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_apikey) = local_var_configuration.api_key {
            let local_var_key = local_var_apikey.key.clone();
            let local_var_value = match local_var_apikey.prefix {
                Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
                None => local_var_key,
            };
            local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<DeleteDocumentsError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn delete_search_override(&self, params: DeleteSearchOverrideParams) -> Result<models::SearchOverrideDeleteResponse, Error<DeleteSearchOverrideError>> {
        let DeleteSearchOverrideParams { collection_name, override_id } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/collections/{collectionName}/overrides/{overrideId}",
            local_var_configuration.base_path,
            collectionName = crate::apis::urlencode(collection_name),
            overrideId = crate::apis::urlencode(override_id)
        );
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_apikey) = local_var_configuration.api_key {
            let local_var_key = local_var_apikey.key.clone();
            let local_var_value = match local_var_apikey.prefix {
                Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
                None => local_var_key,
            };
            local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<DeleteSearchOverrideError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Export all documents in a collection in JSON lines format.
    async fn export_documents(&self, params: ExportDocumentsParams) -> Result<String, Error<ExportDocumentsError>> {
        let ExportDocumentsParams {
            collection_name,
            exclude_fields,
            filter_by,
            include_fields,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/collections/{collectionName}/documents/export",
            local_var_configuration.base_path,
            collectionName = crate::apis::urlencode(collection_name)
        );
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = exclude_fields {
            local_var_req_builder = local_var_req_builder.query(&[("exclude_fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_by {
            local_var_req_builder = local_var_req_builder.query(&[("filter_by", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = include_fields {
            local_var_req_builder = local_var_req_builder.query(&[("include_fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_apikey) = local_var_configuration.api_key {
            let local_var_key = local_var_apikey.key.clone();
            let local_var_value = match local_var_apikey.prefix {
                Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
                None => local_var_key,
            };
            local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<ExportDocumentsError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Fetch an individual document from a collection by using its ID.
    async fn get_document(&self, params: GetDocumentParams) -> Result<serde_json::Value, Error<GetDocumentError>> {
        let GetDocumentParams { collection_name, document_id } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/collections/{collectionName}/documents/{documentId}",
            local_var_configuration.base_path,
            collectionName = crate::apis::urlencode(collection_name),
            documentId = crate::apis::urlencode(document_id)
        );
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_apikey) = local_var_configuration.api_key {
            let local_var_key = local_var_apikey.key.clone();
            let local_var_value = match local_var_apikey.prefix {
                Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
                None => local_var_key,
            };
            local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<GetDocumentError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Retrieve the details of a search override, given its id.
    async fn get_search_override(&self, params: GetSearchOverrideParams) -> Result<models::SearchOverride, Error<GetSearchOverrideError>> {
        let GetSearchOverrideParams { collection_name, override_id } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/collections/{collectionName}/overrides/{overrideId}",
            local_var_configuration.base_path,
            collectionName = crate::apis::urlencode(collection_name),
            overrideId = crate::apis::urlencode(override_id)
        );
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_apikey) = local_var_configuration.api_key {
            let local_var_key = local_var_apikey.key.clone();
            let local_var_value = match local_var_apikey.prefix {
                Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
                None => local_var_key,
            };
            local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<GetSearchOverrideError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_search_overrides(&self, params: GetSearchOverridesParams) -> Result<models::SearchOverridesResponse, Error<GetSearchOverridesError>> {
        let GetSearchOverridesParams { collection_name } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/collections/{collectionName}/overrides",
            local_var_configuration.base_path,
            collectionName = crate::apis::urlencode(collection_name)
        );
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_apikey) = local_var_configuration.api_key {
            let local_var_key = local_var_apikey.key.clone();
            let local_var_value = match local_var_apikey.prefix {
                Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
                None => local_var_key,
            };
            local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<GetSearchOverridesError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// The documents to be imported must be formatted in a newline delimited JSON structure. You can feed the output file from a Typesense export operation directly as import.
    async fn import_documents(&self, params: ImportDocumentsParams) -> Result<String, Error<ImportDocumentsError>> {
        let ImportDocumentsParams {
            collection_name,
            body,
            action,
            batch_size,
            dirty_values,
            remote_embedding_batch_size,
            return_doc,
            return_id,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/collections/{collectionName}/documents/import",
            local_var_configuration.base_path,
            collectionName = crate::apis::urlencode(collection_name)
        );
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = action {
            local_var_req_builder = local_var_req_builder.query(&[("action", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = batch_size {
            local_var_req_builder = local_var_req_builder.query(&[("batch_size", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = dirty_values {
            local_var_req_builder = local_var_req_builder.query(&[("dirty_values", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = remote_embedding_batch_size {
            local_var_req_builder = local_var_req_builder.query(&[("remote_embedding_batch_size", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = return_doc {
            local_var_req_builder = local_var_req_builder.query(&[("return_doc", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = return_id {
            local_var_req_builder = local_var_req_builder.query(&[("return_id", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_apikey) = local_var_configuration.api_key {
            let local_var_key = local_var_apikey.key.clone();
            let local_var_value = match local_var_apikey.prefix {
                Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
                None => local_var_key,
            };
            local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
        };
        local_var_req_builder = local_var_req_builder.json(&body);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<ImportDocumentsError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// A document to be indexed in a given collection must conform to the schema of the collection.
    async fn index_document(&self, params: IndexDocumentParams) -> Result<serde_json::Value, Error<IndexDocumentError>> {
        let IndexDocumentParams {
            collection_name,
            body,
            action,
            dirty_values,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/collections/{collectionName}/documents",
            local_var_configuration.base_path,
            collectionName = crate::apis::urlencode(collection_name)
        );
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = action {
            local_var_req_builder = local_var_req_builder.query(&[("action", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = dirty_values {
            local_var_req_builder = local_var_req_builder.query(&[("dirty_values", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_apikey) = local_var_configuration.api_key {
            let local_var_key = local_var_apikey.key.clone();
            let local_var_value = match local_var_apikey.prefix {
                Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
                None => local_var_key,
            };
            local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
        };
        local_var_req_builder = local_var_req_builder.json(&body);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<IndexDocumentError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// This is especially useful to avoid round-trip network latencies incurred otherwise if each of these requests are sent in separate HTTP requests. You can also use this feature to do a federated search across multiple collections in a single HTTP request.
    async fn multi_search(&self, params: MultiSearchParams) -> Result<models::MultiSearchResult, Error<MultiSearchError>> {
        let MultiSearchParams {
            cache_ttl,
            conversation,
            conversation_id,
            conversation_model_id,
            drop_tokens_mode,
            drop_tokens_threshold,
            enable_highlight_v1,
            enable_overrides,
            enable_synonyms,
            enable_typos_for_alpha_numerical_tokens,
            enable_typos_for_numerical_tokens,
            exclude_fields,
            exhaustive_search,
            facet_by,
            facet_query,
            facet_return_parent,
            facet_strategy,
            filter_by,
            filter_curated_hits,
            group_by,
            group_limit,
            group_missing_values,
            hidden_hits,
            highlight_affix_num_tokens,
            highlight_end_tag,
            highlight_fields,
            highlight_full_fields,
            highlight_start_tag,
            include_fields,
            infix,
            limit,
            max_candidates,
            max_extra_prefix,
            max_extra_suffix,
            max_facet_values,
            min_len_1typo,
            min_len_2typo,
            num_typos,
            offset,
            override_tags,
            page,
            per_page,
            pinned_hits,
            pre_segmented_query,
            prefix,
            preset,
            prioritize_exact_match,
            prioritize_num_matching_fields,
            prioritize_token_position,
            q,
            query_by,
            query_by_weights,
            remote_embedding_num_tries,
            remote_embedding_timeout_ms,
            search_cutoff_ms,
            snippet_threshold,
            sort_by,
            split_join_tokens,
            stopwords,
            synonym_num_typos,
            synonym_prefix,
            text_match_type,
            typo_tokens_threshold,
            use_cache,
            vector_query,
            voice_query,
            multi_search_searches_parameter,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/multi_search", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = cache_ttl {
            local_var_req_builder = local_var_req_builder.query(&[("cache_ttl", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = conversation {
            local_var_req_builder = local_var_req_builder.query(&[("conversation", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = conversation_id {
            local_var_req_builder = local_var_req_builder.query(&[("conversation_id", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = conversation_model_id {
            local_var_req_builder = local_var_req_builder.query(&[("conversation_model_id", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = drop_tokens_mode {
            local_var_req_builder = local_var_req_builder.query(&[("drop_tokens_mode", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = drop_tokens_threshold {
            local_var_req_builder = local_var_req_builder.query(&[("drop_tokens_threshold", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = enable_highlight_v1 {
            local_var_req_builder = local_var_req_builder.query(&[("enable_highlight_v1", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = enable_overrides {
            local_var_req_builder = local_var_req_builder.query(&[("enable_overrides", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = enable_synonyms {
            local_var_req_builder = local_var_req_builder.query(&[("enable_synonyms", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = enable_typos_for_alpha_numerical_tokens {
            local_var_req_builder = local_var_req_builder.query(&[("enable_typos_for_alpha_numerical_tokens", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = enable_typos_for_numerical_tokens {
            local_var_req_builder = local_var_req_builder.query(&[("enable_typos_for_numerical_tokens", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = exclude_fields {
            local_var_req_builder = local_var_req_builder.query(&[("exclude_fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = exhaustive_search {
            local_var_req_builder = local_var_req_builder.query(&[("exhaustive_search", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = facet_by {
            local_var_req_builder = local_var_req_builder.query(&[("facet_by", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = facet_query {
            local_var_req_builder = local_var_req_builder.query(&[("facet_query", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = facet_return_parent {
            local_var_req_builder = local_var_req_builder.query(&[("facet_return_parent", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = facet_strategy {
            local_var_req_builder = local_var_req_builder.query(&[("facet_strategy", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_by {
            local_var_req_builder = local_var_req_builder.query(&[("filter_by", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_curated_hits {
            local_var_req_builder = local_var_req_builder.query(&[("filter_curated_hits", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = group_by {
            local_var_req_builder = local_var_req_builder.query(&[("group_by", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = group_limit {
            local_var_req_builder = local_var_req_builder.query(&[("group_limit", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = group_missing_values {
            local_var_req_builder = local_var_req_builder.query(&[("group_missing_values", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = hidden_hits {
            local_var_req_builder = local_var_req_builder.query(&[("hidden_hits", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = highlight_affix_num_tokens {
            local_var_req_builder = local_var_req_builder.query(&[("highlight_affix_num_tokens", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = highlight_end_tag {
            local_var_req_builder = local_var_req_builder.query(&[("highlight_end_tag", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = highlight_fields {
            local_var_req_builder = local_var_req_builder.query(&[("highlight_fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = highlight_full_fields {
            local_var_req_builder = local_var_req_builder.query(&[("highlight_full_fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = highlight_start_tag {
            local_var_req_builder = local_var_req_builder.query(&[("highlight_start_tag", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = include_fields {
            local_var_req_builder = local_var_req_builder.query(&[("include_fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = infix {
            local_var_req_builder = local_var_req_builder.query(&[("infix", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = limit {
            local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = max_candidates {
            local_var_req_builder = local_var_req_builder.query(&[("max_candidates", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = max_extra_prefix {
            local_var_req_builder = local_var_req_builder.query(&[("max_extra_prefix", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = max_extra_suffix {
            local_var_req_builder = local_var_req_builder.query(&[("max_extra_suffix", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = max_facet_values {
            local_var_req_builder = local_var_req_builder.query(&[("max_facet_values", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = min_len_1typo {
            local_var_req_builder = local_var_req_builder.query(&[("min_len_1typo", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = min_len_2typo {
            local_var_req_builder = local_var_req_builder.query(&[("min_len_2typo", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = num_typos {
            local_var_req_builder = local_var_req_builder.query(&[("num_typos", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = offset {
            local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = override_tags {
            local_var_req_builder = local_var_req_builder.query(&[("override_tags", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = page {
            local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = per_page {
            local_var_req_builder = local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pinned_hits {
            local_var_req_builder = local_var_req_builder.query(&[("pinned_hits", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pre_segmented_query {
            local_var_req_builder = local_var_req_builder.query(&[("pre_segmented_query", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = prefix {
            local_var_req_builder = local_var_req_builder.query(&[("prefix", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = preset {
            local_var_req_builder = local_var_req_builder.query(&[("preset", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = prioritize_exact_match {
            local_var_req_builder = local_var_req_builder.query(&[("prioritize_exact_match", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = prioritize_num_matching_fields {
            local_var_req_builder = local_var_req_builder.query(&[("prioritize_num_matching_fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = prioritize_token_position {
            local_var_req_builder = local_var_req_builder.query(&[("prioritize_token_position", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = q {
            local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = query_by {
            local_var_req_builder = local_var_req_builder.query(&[("query_by", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = query_by_weights {
            local_var_req_builder = local_var_req_builder.query(&[("query_by_weights", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = remote_embedding_num_tries {
            local_var_req_builder = local_var_req_builder.query(&[("remote_embedding_num_tries", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = remote_embedding_timeout_ms {
            local_var_req_builder = local_var_req_builder.query(&[("remote_embedding_timeout_ms", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = search_cutoff_ms {
            local_var_req_builder = local_var_req_builder.query(&[("search_cutoff_ms", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = snippet_threshold {
            local_var_req_builder = local_var_req_builder.query(&[("snippet_threshold", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = sort_by {
            local_var_req_builder = local_var_req_builder.query(&[("sort_by", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = split_join_tokens {
            local_var_req_builder = local_var_req_builder.query(&[("split_join_tokens", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = stopwords {
            local_var_req_builder = local_var_req_builder.query(&[("stopwords", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = synonym_num_typos {
            local_var_req_builder = local_var_req_builder.query(&[("synonym_num_typos", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = synonym_prefix {
            local_var_req_builder = local_var_req_builder.query(&[("synonym_prefix", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = text_match_type {
            local_var_req_builder = local_var_req_builder.query(&[("text_match_type", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = typo_tokens_threshold {
            local_var_req_builder = local_var_req_builder.query(&[("typo_tokens_threshold", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = use_cache {
            local_var_req_builder = local_var_req_builder.query(&[("use_cache", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = vector_query {
            local_var_req_builder = local_var_req_builder.query(&[("vector_query", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = voice_query {
            local_var_req_builder = local_var_req_builder.query(&[("voice_query", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_apikey) = local_var_configuration.api_key {
            let local_var_key = local_var_apikey.key.clone();
            let local_var_value = match local_var_apikey.prefix {
                Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
                None => local_var_key,
            };
            local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
        };
        local_var_req_builder = local_var_req_builder.json(&multi_search_searches_parameter);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<MultiSearchError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Search for documents in a collection that match the search criteria.
    async fn search_collection(&self, params: SearchCollectionParams) -> Result<models::SearchResult, Error<SearchCollectionError>> {
        let SearchCollectionParams {
            collection_name,
            cache_ttl,
            conversation,
            conversation_id,
            conversation_model_id,
            drop_tokens_mode,
            drop_tokens_threshold,
            enable_highlight_v1,
            enable_overrides,
            enable_synonyms,
            enable_typos_for_alpha_numerical_tokens,
            enable_typos_for_numerical_tokens,
            exclude_fields,
            exhaustive_search,
            facet_by,
            facet_query,
            facet_return_parent,
            facet_strategy,
            filter_by,
            filter_curated_hits,
            group_by,
            group_limit,
            group_missing_values,
            hidden_hits,
            highlight_affix_num_tokens,
            highlight_end_tag,
            highlight_fields,
            highlight_full_fields,
            highlight_start_tag,
            include_fields,
            infix,
            limit,
            max_candidates,
            max_extra_prefix,
            max_extra_suffix,
            max_facet_values,
            min_len_1typo,
            min_len_2typo,
            num_typos,
            offset,
            override_tags,
            page,
            per_page,
            pinned_hits,
            pre_segmented_query,
            prefix,
            preset,
            prioritize_exact_match,
            prioritize_num_matching_fields,
            prioritize_token_position,
            q,
            query_by,
            query_by_weights,
            remote_embedding_num_tries,
            remote_embedding_timeout_ms,
            search_cutoff_ms,
            snippet_threshold,
            sort_by,
            split_join_tokens,
            stopwords,
            synonym_num_typos,
            synonym_prefix,
            text_match_type,
            typo_tokens_threshold,
            use_cache,
            vector_query,
            voice_query,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/collections/{collectionName}/documents/search",
            local_var_configuration.base_path,
            collectionName = crate::apis::urlencode(collection_name)
        );
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = cache_ttl {
            local_var_req_builder = local_var_req_builder.query(&[("cache_ttl", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = conversation {
            local_var_req_builder = local_var_req_builder.query(&[("conversation", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = conversation_id {
            local_var_req_builder = local_var_req_builder.query(&[("conversation_id", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = conversation_model_id {
            local_var_req_builder = local_var_req_builder.query(&[("conversation_model_id", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = drop_tokens_mode {
            local_var_req_builder = local_var_req_builder.query(&[("drop_tokens_mode", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = drop_tokens_threshold {
            local_var_req_builder = local_var_req_builder.query(&[("drop_tokens_threshold", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = enable_highlight_v1 {
            local_var_req_builder = local_var_req_builder.query(&[("enable_highlight_v1", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = enable_overrides {
            local_var_req_builder = local_var_req_builder.query(&[("enable_overrides", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = enable_synonyms {
            local_var_req_builder = local_var_req_builder.query(&[("enable_synonyms", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = enable_typos_for_alpha_numerical_tokens {
            local_var_req_builder = local_var_req_builder.query(&[("enable_typos_for_alpha_numerical_tokens", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = enable_typos_for_numerical_tokens {
            local_var_req_builder = local_var_req_builder.query(&[("enable_typos_for_numerical_tokens", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = exclude_fields {
            local_var_req_builder = local_var_req_builder.query(&[("exclude_fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = exhaustive_search {
            local_var_req_builder = local_var_req_builder.query(&[("exhaustive_search", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = facet_by {
            local_var_req_builder = local_var_req_builder.query(&[("facet_by", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = facet_query {
            local_var_req_builder = local_var_req_builder.query(&[("facet_query", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = facet_return_parent {
            local_var_req_builder = local_var_req_builder.query(&[("facet_return_parent", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = facet_strategy {
            local_var_req_builder = local_var_req_builder.query(&[("facet_strategy", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_by {
            local_var_req_builder = local_var_req_builder.query(&[("filter_by", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_curated_hits {
            local_var_req_builder = local_var_req_builder.query(&[("filter_curated_hits", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = group_by {
            local_var_req_builder = local_var_req_builder.query(&[("group_by", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = group_limit {
            local_var_req_builder = local_var_req_builder.query(&[("group_limit", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = group_missing_values {
            local_var_req_builder = local_var_req_builder.query(&[("group_missing_values", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = hidden_hits {
            local_var_req_builder = local_var_req_builder.query(&[("hidden_hits", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = highlight_affix_num_tokens {
            local_var_req_builder = local_var_req_builder.query(&[("highlight_affix_num_tokens", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = highlight_end_tag {
            local_var_req_builder = local_var_req_builder.query(&[("highlight_end_tag", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = highlight_fields {
            local_var_req_builder = local_var_req_builder.query(&[("highlight_fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = highlight_full_fields {
            local_var_req_builder = local_var_req_builder.query(&[("highlight_full_fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = highlight_start_tag {
            local_var_req_builder = local_var_req_builder.query(&[("highlight_start_tag", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = include_fields {
            local_var_req_builder = local_var_req_builder.query(&[("include_fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = infix {
            local_var_req_builder = local_var_req_builder.query(&[("infix", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = limit {
            local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = max_candidates {
            local_var_req_builder = local_var_req_builder.query(&[("max_candidates", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = max_extra_prefix {
            local_var_req_builder = local_var_req_builder.query(&[("max_extra_prefix", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = max_extra_suffix {
            local_var_req_builder = local_var_req_builder.query(&[("max_extra_suffix", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = max_facet_values {
            local_var_req_builder = local_var_req_builder.query(&[("max_facet_values", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = min_len_1typo {
            local_var_req_builder = local_var_req_builder.query(&[("min_len_1typo", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = min_len_2typo {
            local_var_req_builder = local_var_req_builder.query(&[("min_len_2typo", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = num_typos {
            local_var_req_builder = local_var_req_builder.query(&[("num_typos", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = offset {
            local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = override_tags {
            local_var_req_builder = local_var_req_builder.query(&[("override_tags", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = page {
            local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = per_page {
            local_var_req_builder = local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pinned_hits {
            local_var_req_builder = local_var_req_builder.query(&[("pinned_hits", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pre_segmented_query {
            local_var_req_builder = local_var_req_builder.query(&[("pre_segmented_query", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = prefix {
            local_var_req_builder = local_var_req_builder.query(&[("prefix", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = preset {
            local_var_req_builder = local_var_req_builder.query(&[("preset", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = prioritize_exact_match {
            local_var_req_builder = local_var_req_builder.query(&[("prioritize_exact_match", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = prioritize_num_matching_fields {
            local_var_req_builder = local_var_req_builder.query(&[("prioritize_num_matching_fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = prioritize_token_position {
            local_var_req_builder = local_var_req_builder.query(&[("prioritize_token_position", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = q {
            local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = query_by {
            local_var_req_builder = local_var_req_builder.query(&[("query_by", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = query_by_weights {
            local_var_req_builder = local_var_req_builder.query(&[("query_by_weights", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = remote_embedding_num_tries {
            local_var_req_builder = local_var_req_builder.query(&[("remote_embedding_num_tries", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = remote_embedding_timeout_ms {
            local_var_req_builder = local_var_req_builder.query(&[("remote_embedding_timeout_ms", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = search_cutoff_ms {
            local_var_req_builder = local_var_req_builder.query(&[("search_cutoff_ms", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = snippet_threshold {
            local_var_req_builder = local_var_req_builder.query(&[("snippet_threshold", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = sort_by {
            local_var_req_builder = local_var_req_builder.query(&[("sort_by", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = split_join_tokens {
            local_var_req_builder = local_var_req_builder.query(&[("split_join_tokens", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = stopwords {
            local_var_req_builder = local_var_req_builder.query(&[("stopwords", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = synonym_num_typos {
            local_var_req_builder = local_var_req_builder.query(&[("synonym_num_typos", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = synonym_prefix {
            local_var_req_builder = local_var_req_builder.query(&[("synonym_prefix", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = text_match_type {
            local_var_req_builder = local_var_req_builder.query(&[("text_match_type", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = typo_tokens_threshold {
            local_var_req_builder = local_var_req_builder.query(&[("typo_tokens_threshold", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = use_cache {
            local_var_req_builder = local_var_req_builder.query(&[("use_cache", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = vector_query {
            local_var_req_builder = local_var_req_builder.query(&[("vector_query", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = voice_query {
            local_var_req_builder = local_var_req_builder.query(&[("voice_query", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_apikey) = local_var_configuration.api_key {
            let local_var_key = local_var_apikey.key.clone();
            let local_var_value = match local_var_apikey.prefix {
                Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
                None => local_var_key,
            };
            local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<SearchCollectionError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Update an individual document from a collection by using its ID. The update can be partial.
    async fn update_document(&self, params: UpdateDocumentParams) -> Result<serde_json::Value, Error<UpdateDocumentError>> {
        let UpdateDocumentParams {
            collection_name,
            document_id,
            body,
            dirty_values,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/collections/{collectionName}/documents/{documentId}",
            local_var_configuration.base_path,
            collectionName = crate::apis::urlencode(collection_name),
            documentId = crate::apis::urlencode(document_id)
        );
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = dirty_values {
            local_var_req_builder = local_var_req_builder.query(&[("dirty_values", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_apikey) = local_var_configuration.api_key {
            let local_var_key = local_var_apikey.key.clone();
            let local_var_value = match local_var_apikey.prefix {
                Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
                None => local_var_key,
            };
            local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
        };
        local_var_req_builder = local_var_req_builder.json(&body);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<UpdateDocumentError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// The filter_by query parameter is used to filter to specify a condition against which the documents are matched. The request body contains the fields that should be updated for any documents that match the filter condition. This endpoint is only available if the Typesense server is version `0.25.0.rc12` or later.
    async fn update_documents(&self, params: UpdateDocumentsParams) -> Result<models::UpdateDocuments200Response, Error<UpdateDocumentsError>> {
        let UpdateDocumentsParams { collection_name, body, filter_by } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/collections/{collectionName}/documents",
            local_var_configuration.base_path,
            collectionName = crate::apis::urlencode(collection_name)
        );
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = filter_by {
            local_var_req_builder = local_var_req_builder.query(&[("filter_by", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_apikey) = local_var_configuration.api_key {
            let local_var_key = local_var_apikey.key.clone();
            let local_var_value = match local_var_apikey.prefix {
                Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
                None => local_var_key,
            };
            local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
        };
        local_var_req_builder = local_var_req_builder.json(&body);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<UpdateDocumentsError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Create or update an override to promote certain documents over others. Using overrides, you can include or exclude specific documents for a given query.
    async fn upsert_search_override(&self, params: UpsertSearchOverrideParams) -> Result<models::SearchOverride, Error<UpsertSearchOverrideError>> {
        let UpsertSearchOverrideParams {
            collection_name,
            override_id,
            search_override_schema,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/collections/{collectionName}/overrides/{overrideId}",
            local_var_configuration.base_path,
            collectionName = crate::apis::urlencode(collection_name),
            overrideId = crate::apis::urlencode(override_id)
        );
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_apikey) = local_var_configuration.api_key {
            let local_var_key = local_var_apikey.key.clone();
            let local_var_value = match local_var_apikey.prefix {
                Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
                None => local_var_key,
            };
            local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
        };
        local_var_req_builder = local_var_req_builder.json(&search_override_schema);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<UpsertSearchOverrideError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }
}

/// struct for typed errors of method [`delete_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDocumentError {
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_documents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDocumentsError {
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_search_override`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSearchOverrideError {
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`export_documents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExportDocumentsError {
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDocumentError {
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_search_override`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSearchOverrideError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_search_overrides`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSearchOverridesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`import_documents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ImportDocumentsError {
    Status400(models::ApiResponse),
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`index_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndexDocumentError {
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`multi_search`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MultiSearchError {
    Status400(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_collection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchCollectionError {
    Status400(models::ApiResponse),
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDocumentError {
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_documents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDocumentsError {
    Status400(models::ApiResponse),
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upsert_search_override`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpsertSearchOverrideError {
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}
